# 操作系统学习简记三——虚拟内存

## 基础

### 起因

* 
需要更大、更快、更便宜的存储器
* 
存储器有很明显的层次结构，交由程序员管理太过复杂，由操作系统统一管理更加合理

### 技术发展

* 覆盖技术：程序员手动管理，只把需要的指令和数据放在内存中。
* 交换技术：自动管理，把暂时不运行的程序放到硬盘中，但需要多次倒换，开销不小。
* 虚拟存储技术：基于分段、分页

## 覆盖技术

### 原理

将逻辑按照自身逻辑，分为互相独立的若干个模块以及一个常驻模块。常驻模块负责装卸独立模块，模块在不同时间使用同一个内存区。

### 缺点

* 程序员管理复杂
* 覆盖模块之间的频繁切换，其实是以时间换空间

## 交换技术

### 原理

多个进程同时存在时，由操作系统进行管理，把等待状态的进程做转移，空出更多空间。一个重要特征是，交换的粒度是整个进程。

### 问题

* 交换时机：内存空间不够或者有不够的风险
* 交换区的大小
* 程序换入时的重定位：由于重新换入时，程序待的地址和原来很可能不同，会导致原先的地址失效，于是需要重定位，最好使用动态地址映射，也即建立新的页表，保证逻辑地址和原来相同，至于物理地址映射不同，完全没有影响。

### 与覆盖技术的区别

* 覆盖技术是一个程序中的各个模块之间，粒度较小，交换技术发生在整个内存空间中的各个进程之间，粒度较大。
* 覆盖技术需要程序员管理，交换技术由操作系统管理，对程序员透明。
* 覆盖技术是仅仅使用物理内存进行覆盖，而交换技术多使用了外存，如硬盘等，做交换中介。

## 虚拟内存

### 基本概念

* 实现内存和外存的交换，但实现基于分段或分页的交换，只对进程的部分内容做交换，以页或段为粒度大小。
* 吸收交换技术的优点，可以由操作系统自动管理。

### 局部性原理

* 时间局部性：同一条指令或同一个数据的使用和下次使用集中在一个较短时间内，也就是说，同一个指令或数据的被访问之后，往往在较短时间内会有下一次访问。

* 
  空间局部性：当前指令/数据和临近的指令/数据，往往集中在一个较小的地址区域内。

* 
  局部性应用原理实例：

  1024个int值大小为4k，一般为一个页，参考一下两种访问二位数组的方法，假设只给了4k的内存大小。

  + 对第一种方式，每次访问二位数组，都产生缺页中断，则一共会产生**1024/*1024**次缺页。
  + 对第二种方式，只会产生**1024**次缺页。

```java
for(int i = 0; i < 1024; i++){
    for(int j = 0; j < 1024; j++){
        a[i][j] = 0;
    }
}
for(int j = 0; j < 1024; i++){
    for(int i = 0; i < 1024; j++){
        a[i][j] = 0;
    }
}
```
### 实现——虚拟页式内存管理

#### 分页机制

分页机制详见上一篇文章，这里简述，CPU根据逻辑地址中的页号，从页表中查询出帧号。页表的索引是页号，而元素值是某些标记位加上帧号。标记位中包括一个是否存在的标记，0表示不存在该页号到物理地址的映射关系，1则存在。这个标记位在虚拟内存的具体实现中有重要作用。

#### 基本思路

* 用户程序在调入内存运行时，只加载入需要的页面，也即建立该页表时，先建立部分映射关系，而多余的映射关系不建立。
* 页调入：在运行过程中，如果发现要运行的程序或者要使用的数据不在内存中，则向系统发出缺页中断，此时系统再从外存中调入需要使用的内存页。
* 页换出：有多种页面置换算法，下文详述。

> 页表：页表表项为了适应虚拟页式内存管理的需要，需要设置一些标记位，例如
>
> 驻留位：表示该页在内存还是外存，如果该位为1，意味着存在该逻辑页到物理帧的映射关系。如果为0，会产生缺页中断。
>
> 保护位：表示允许对该页做什么类型的操作，该标记位不止一位，操作类型如只读、可读写、可执行等等。
>
> 修改位：表示该页在内存中是否被修改过。如果是1，意味着该页和外村中的数据不一致，所以在换出时需要更新外存中的数据。
>
> 访问位：该页在内存中是否被访问过，包括读和写。在页置换算法中使用。

#### 缺页中断处理过程

1. 如果物理内存中有空闲空间，则分配一个物理页帧f，然后转第4步；否则转2；
1. 采用某种页面置换算法，选择一个物理页帧f，查看其对应的页表项的标记位，判断是否被修改过，如果修改过，则将原物理页帧f写回外存；如果没有修改过，直接释放；
1. 将原页帧f对应的页表项的驻留位改为0
1. 将需要访问的页从外存中加载入f中，即写入或者替换f；
1. 修改对应页表中的对应页表项，把帧号写为f，驻留位置为1；
1. 重新执行被缺页中断的指令

#### 存储类型

* 内存数据、指令
* 后备存储：硬盘中的数据、指令，在运行到需要时，由操作系统调入内存；
* 动态链接库：存在于硬盘中，操作系统需要调用的库，也是在运行需要时调入内存；
* 程序动态产生的数据：不属于上面几种，一般放在操作系统挂载的**swap分区**。

> 操作系统开辟的swap分区，并不是用来放程序和数据的，而是用来放程序在执行过程中动态产生的多余数据，这些数据原本位于内存中，需要在换出时即使用swap分区。

#### 虚拟内存性能

在应用虚拟内存的系统中，有效访问时间（effective memory access time，EAT）

```
EAT = 访问内存时间 × 页表命中几率 + page fault处理时间 × page fault几率
```

而这其中，处理时间影响程度最大的因素是page fault处理时间，因为访问内存时间在对比page fault处理时间非常小，page fault处理时间包括磁盘访问时间等。

所以在优化访问时，可以利用降低page fault几率，即增加页表命中几率。

### 局部页面置换算法

#### 目标

* 缺页中断，且内存已满时，选择哪个页面被置换。
* 尽量减少换入换出的次数;
* 页面锁定。常驻某些页面。可以使用锁定标记位。

#### 最优页面置换算法

##### 基本思路

对每一个逻辑页面，计算其到下一次访问需要多长时间，置换时间最长的页面。 但实际上无法实现，因为操作系统无法计算每个页面的等待时间。 可用作评价标准，在模拟器上运行两次，第二次即可使用该算法。

#### 先进先出算法

##### 基本思路

选择驻留时间最长的。以一个链表维护纪录页面使用顺序，链表头就是驻留时间最长的。

##### 缺点

* 性能差
* Belady现象。分配物理页帧越多，缺页率反而提高。FIFO的特征与置换的目的不同，所以其置换出去的页面有可能是要使用的。

#### 最近最久未使用算法（LRU，Least Recently Used）

##### 基本思路

本质上是对FIFO进行动态调整。也是一种先进先出。 最久未使用。和最长驻留不一样。 基于局部性原理，有一定的合理性。

##### 实现方法

* 维护访问顺序链表
* 维护访问顺序堆栈。这两种方法都需要更新数据结构，每次都要判断是否需要更新，如果需要，还要调整顺序。开销很大

#### 时钟页面置换

对LRU的近似，对FIFO的改进。对LRU算法中顺序调整方式的优化。

##### 基本思路

* 使用页表项中的访问位（Access Bit，读写访问）。当页面装入时，初始化为0;被访问后，置为1;
* 页面组织环形链表，指针指向最先进来的页面。不需要调整链表顺序。
* 需要置换时，考察指针所指，若访问位为0，置换;若访问位为1，置0，移动指针到下一格，继续考察。
* 替换完成后，指针移动下一格。

##### 原理

近似LRU，但不是以数据结构顺序来判断LR，而是以进入顺序和最近是否被访问的标记位来综合判断，其效果是对整个内存页面链表环形扫描判断，既对FIFO进行了访问顺序判断，又对LRU减少了维护数据结构的开销。 实质是一种折中。

#### 二次机会法

> Dirty Bit，被写后置1，即修改过。这个位标志着该页被替换出去时，是否要写回硬盘。如果对页执行读操作，Abit为1，Dbit为0;写操作，两个都为1。

##### 实现

改进时钟置换，由只考虑Abit，但综合考虑Abit和Dbit。 如果二0，替换;一0一1，置二0;二1，Abit置0，Dbit置1。

###### 原理

由于Dbit为1的页，换出时需要访问硬盘，而为0则直接释放，所以给执行过写操作的页两次机会，减少访问硬盘次数。

#### 最不常用法，LFU

##### 基本思路

选择访问次数最少的页面

#### 工作集模型

##### 定义

一个进程当前正在使用的逻辑页面集合，可用一个二元函数W(t，A)表示。 t时当前时刻 A称为工作集窗口，即一个定长的页面访问时间窗口 W=在当前时刻t之前的A时间窗口中所有页面的组成的集合 W绝对值指工作集大小，也是页面数目。 **工作集中的页面不一定实际存在于内存中，其描述的是一种需求**

#### 常驻集

##### 定义

当前时刻进程实际驻留在内存中的页帧集合。

#### 页面置换过程中的问题

应用进程在运行过程中，所需要的内存空间并不是固定的，如果可以动态调整，会增加利用率。

而要解决这个问题，可以在系统全局下对页进行调整，即使不同进程之间对内存使用存在竞争关系，以下两种算法可以实现这一需求。

#### 工作集页置换算法

本质上是根据工作集的改变，对常驻集进行动态调整。

##### 实现

* 缺页中断需要置换时，换出不在工作集窗口中的页
* 工作集窗口滑动时，换出掉出窗口的页

#### 缺页率页置换算法

本质上是对工作集页置换算法的改进，改进对工作集调整的方式

> 缺页率：缺页次数/内存访问次数 或 缺页平均间隔大小的倒数

##### 实现

每两次缺页中断之间的时间间隔和一个阈值做比较，如果大，说明内存足够；如果小，说明分配的页不够；

* 内存页面足够时，移除在两次中断之间的窗口中没有被引用的页；
* 内存页面不足时，正常添加缺失页。
