# 操作系统学习简记一——启动、系统调用、中断、异常

## 启动

### 启动过程

1. BIOS程序被储存在闪存中，计算机加电后会自动从BIOS加载程序到**一段固定的内存空间**并执行。
1. BIOS启动后先进行硬件检测，然后去硬盘里找到Bootloader（Bootloader是负责启动真正的OS的程序），将其加载进**一段固定的内存空间**并执行。Bootloader一般放在硬盘的第一个主引导分区。
1. Bootloader找到OS在硬盘中的分区，并将OS加载入内存，然后将指令寄存器跳给OS所在的内存地址，也就是把操作权交出去。

### 发展过程

* BIOS：固话到主板上的程序，完成最基础的功能

  * 只能引导固定的一个分区；
  * MBR：支持多分区、多磁盘，但数量有限制；
  * GPT：增加数量限制。
* UEFI：在所有平台上统一一致的操作系统启动服务。修改了如，对加载介质的可信性检查。

## 系统调用、中断、异常

### 概念和特征

操作系统负责做应用程序和硬件的中间层，这三个概念是操作系统分别与应用程序和硬件的打交道的方式，是跨越边界的行为。

* 
  来源

  * 中断：外设。硬件和网络找操作系统。
  * 异常：应用程序的错误
  * 系统调用：正常的应用程序请求
* 
  处理时间

  * 中断：异步
  * 异常：同步
  * 系统调用：异步或同步都有
* 响应

  * 中断：是持续的，对应用程序是透明的。操作系统不想打断影响应用程序，而是默默处理，应用程序不会被动感知到中断。
  * 异常：应用程序会有响应，如被杀死或者重复执行原指令。
  * 系统调用：等待或者继续异步执行。

### 处理机制

* 
  中断

  * 
    硬件：设置标记寄存器，并设置中断号，用来指定中断类型进而决定由哪段程序处理中断。
  * 软件：
    1. 保存当前的状态
    2. 根据中断号找到对应的中断程序，执行
    3. 清除中断标记
    4. 恢复保存的状态（所以不会打断原执行状态）
* 异常：错误指令有对应的异常编号
  1. 保存现场
  * 异常处理：杀死异常程序或重新执行异常指令（比如原先的条件不满足，重新尝试执行）
  * 恢复现场
* 
  系统调用：应用程序通过系统调用接口访问，也有进行编号

  * 涉及到用户态和内核态的特权级转换。内核态可以执行所有指令，用户态某些指令无法执行。
  * 同个应用程序内的函数调用是同个堆栈的操作，而执行系统调用需要切换堆栈。

### 开销

* 
  时间
* 
  空间

  * 
  建立编号与服务程序的映射关系
  * 
    对现场保护的堆栈应用
  * 验证参数的合法性（安全保障）
  * 内核与应用程序之间的参数或执行结果的传递
  * 内核独立地址空间
