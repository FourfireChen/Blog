# 操作系统学习简记六——进程管理

## 上下文切换

* 暂停当前运行进程，从运行状态变成其他状态；
* 调度另一个进程从就绪状态变为运行状态。

## 进程创建

### Unix进程创建：fork/exec

* 
  fork将一个进程复制为两个

  parent(old PID), child(new PID)

* 
  exec用新程序重写当前进程的内存（常用于fork后，为新进程做加载执行）

  PID没有改变

### 系统初始化的进程

ucore中，系统初始化执行`proc_init()`函数，这个函数会创建：

* IdleProc空闲进程：如果系统处于空闲状态，会执行空闲进程。这种进程的优先级是最低的。
* InitProc初始化进程。

### fork开销

* 子进程分配内存
* 复制父进程内存和cpu寄存器

但是在很多情况下fork后都会执行exec，此时复制就是多余的，这部分开销是可以节约的。Win就是通过一个系统调用完成了创建和加载，节省了复制这一步。现代操作系统的做法：

* UNIX早期提供了vfork，一种轻量级的fork，也支持不复制；
* 现在的复制都是写时复制，也就意味着一旦调用了exec，会把整个内存覆盖，那其实复制这一步就不会执行。

## 进程加载

* 从外存上读取程序，并覆盖整个内存；
* 堆、栈等都会被覆盖。

## 进程等待和结束

### wait

* 
  `wait()`系统调用用于父进程等待子进程的结束

* 子进程结束时调用`exit()`向父进程返回一个值，等待父进程的处理；

* 父进程通过`wait()`接收并处理返回值；

* 
  `wait()`的两种情况：父进程调用`wait()`后：

  * 子进程还存活，父进程进入等待状态，等待子进程返回，直到某子进程执行`exit()`；

  * 有僵尸子进程在等待，即子进程在父进程执行`wait()`前就调用了`exit()`，这时子进程在等待父进程处理，则此时`wait()`立即返回；

  * 无子进程结束，直接返回。

### exit

完成进程资源的回收

* 
  结果

  * 返回一个值给父进程；
  * 关闭文件等资源；
  * 释放内存；
  * 
    释放大部分内核数据结构；
  * 
    检查父进程是否存活

    * 存活，自己进入僵尸状态，等待父进程的处理；
    * 不存活，释放所有数据结构；
  * 清理所有等待的僵尸进程。

## 其他进程控制

### 优先级控制

* 
  `nice()`调用指定进程的初始优先级；
* 
  Unix中进程优先级会随时间衰减；

### 调试支持

`ptrace()`允许一个进程查看、控制另一个进程；

### 定时

`sleep()`让进程在等待队列等待，定时自己醒。
