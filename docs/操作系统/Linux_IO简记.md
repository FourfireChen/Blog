# Linux I/O简记

## 缓存IO

Linux默认的IO操作都是缓存IO，数据从源出发，不会被直接传送到目的，而是要经过内核，通过这种方式保证了内核对IO操作的可控。内核为IO提供了一个数据缓冲区，数据从源出发，先被拷贝到内核的缓冲区中，然后才从缓冲区拷贝到目的进程的用户地址空间。

## IO模式

Linux为IO提供了5种方案：

1. 阻塞IO
1. 非阻塞IO
1. IO多路复用
1. 信号驱动IO
1. 异步IO

### 1. 阻塞IO

Linux中，socket默认都是阻塞IO，用户进程通过系统调用，向内核索要数据read，内核会进行数据准备（比如网络IO中等待数据到达）。这个数据准备过程需要事件，而阻塞IO的特点就是在数据准备的过程中，用户进程会被阻塞，直到内核准备好了数据，才返回结果给用户进程，使用户进程唤醒。

### 2. 非阻塞IO

用户进程发出read，如果内核还没有准备好，会返回error，用户进程不需要等待，但是它取不到数据的可能性很大，需要不断地发出read请求，直到内核准备好了数据。

### 3. IO多路复用

IO多路复用常见于select、poll、epoll。多路IO顾名思义同时进行多个IO，它的意义在于同时与多个Socket进行IO，只要监听列表中有一个或者多个socket有数据到来，用户进程就会被唤醒，通知处理。下面分别讲讲select、poll和epoll

#### 3.1 select

```c
int select(int nfds, fd_set readfds, fd_set writefds, fd_set exceptfds, struct timeval timeout);
```

select函数的主要逻辑是，传入要监听的文件描述符，用户进程需要将这些文件描述符fds拷贝给内核，而且这里文件描述符的数量是有限的，一般是被宏定义为1024，然后内核对fds指向的socket进行监听，挨个进行poll逻辑，检查是不是有可读事件，如果一个都没有，用户进程陷入阻塞。如果有事件到来，内核就会唤醒用户进程，接下来用户进程需要对每个socket尝试读取。

所以select有很大的缺点

1. fds集合的大小只能是1024以下，太小了
1. fds需要从用于空间拷贝到内核空间，太麻烦了。
1. 只要有一个fds是有数据可读的，所有socket都要被遍历一次，太惨了。

#### 3.2 poll

poll其实有点傻，poll只解决了1024问题，就是把监听的文件大小变大了，但没有解决第2、3个问题，这就意味着，监听的文件数量可以很大，但每次只要有一个事件到来，就要遍历所有的socket，这就很尴尬了，一旦大并发，不言而喻。

#### 3.3 epoll

select的第一个缺点很好解决，解决第二、三个缺点比较棘手，epoll采用了两个思想，一是添加中间层封装简化处理，二是分散事件处理，将高频、低频、不同事件分开处理，提高处理精确度。

##### 3.3.1 分散处理优化拷贝消耗

epoll将高频调用的唤醒/等待与低频调用的添加/删除/修改fd分开。唤醒、通知回调处理、等待这块的逻辑，epoll采用了内存映射，将内核空间中存储要返回给用户空间的数据的这块空间，映射到用户空间中，这样就避免了多次的内存拷贝，用户空间能直接访问到返回的数据。添加删除修改监听事件的逻辑，则是被分开进行处理，减少冗余的内存占用。

##### 3.3.2 中间层实线按需遍历

epoll添加了中间层用来精确处理有数据返回的fds，只将有数据的fds暴露给用户进程，这样就避免了用户进程每次都要遍历所有监听的socket，极大地减少了内存占用。在select/poll中，用户进程会睡眠在一个包含其监听的所有socket的集合上，每次这个集合中有准备好的socket，就会唤醒该用户进程。而在epoll中，用户进程则是睡眠在epoll提供的中间层上，中间层再引入一个wait_entry_sk，与每个监听的socket一一对应，然后睡眠在socket集合上，每当集合中有事件来临，则通知wait_entry_sk，将它对应的socket放入中间层提供的ready_list中，然后唤醒用户进程去处理ready_list。

### 4. 信号驱动IO

信号驱动IO是一种半阻塞的IO，在准备数据阶段不阻塞，用户进程发送read后，直接返回。而等到数据准备完成之后，内核给用户空间发信号，通知用户进程阻塞，然后再将数据从内核空间复制到用户空间，这个过程是阻塞的。这种IO方式用得比较少。

### 5. 异步IO

异步IO在整个IO过程中均不阻塞，用户进程发起read操作之后，立即返回，而内核接收请求之后，进行数据准备，并且在数据准备完成之后，将数据复制到用户进程空间，整个过程均不阻塞用户进程，完成之后再发送信号通知用户进程读取数据。
