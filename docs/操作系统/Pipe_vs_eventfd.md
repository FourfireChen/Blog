# 两种IPC方式 Pipe vs eventfd

四火想专门对比这两种IPC方式的原因是，这些天在看Android的消息处理机制，书上的源码用的是老版本的Android，使用的IPC是管道，但最新版本的AOSP中，消息处理机制使用的IPC方式已经改为eventfd了。好奇心激发我去了解了一下，有必要记录下来。

## pipe管道

管道是最原始最基本的IPC机制，用于在进程之间完成数据传递。管道的特点非常鲜明：管道的数据传输是单向的，只能一端写一端读，所以它也采用了两个文件描述符引用，一个表示读端一个表示写端。

对管道进行读写实质上是对内核空间中的一片区域进行读写，管道是由内核管理的一个缓冲区，相当于我们放入内存中的一张纸，但这张纸读和写是完全分开的，管道的一端连接一个进程的输入，另一端连接一个进程的输出。

管道分两种，一种是无名管道，这种管道一般是存在与父子进程或者兄弟进程之间，在Linux系统中可以根据特殊的系统调用，创建一条单向连接的管道，联通父子进程或兄弟进程。还有一种是命名管道，即将管道抽象为文件存放于文件系统之中，等待进程通过该文件与管道建立连接。

## eventfd

eventfd是Linux系统后来才引入的另一种轻量级的IPC方式，不同进程可以通过eventfd机制建立起一个共享的计数器，这个计数器由内核负责维护，充当了信息的角色，与它关联的进程可以对其进行读写，从而起到进程间通讯的目的。

### 提供的方法：

* 
eventfd：创建一个eventfd，返回一个文件描述符，通过该文件描述符可对eventfd进行读写操作。
* 
read:读取计数器中的值：

* 计数器中的值大于0，非初始状态

* 设置了EFD_SEMAPHORE标志，返回1，且计数器中的值减1，这个模式是为跨进程做递减标记等而设计及的。
* 没有设置EFD_SEMAPHORE标志，返回计数器中的值，计数器清零
* 计数器中的值等于0，说明没有人写入值，初始状态默认为0

* 设置了EFD_NOBLOCK标志，返回-1，不阻塞。
* 没有设置EFD_NOBLOCK标记，阻塞直到计数器中的值大于0
* write：向计数器写值，写入的值会和原先计数器中的值累加

* 写入的值和原先计数器中的值的和小于0xFFFFFFFFFFFFFFFE，写入成功
* 否则

* 设置了EFD_NONBLOCK标志，返回-1
* 没有设置，阻塞直到read
* close关闭

### 对比Pipe和eventfd

eventfd是Linux在后版本中才提出来的一种IPC通讯方式，它更加轻量级，也更加灵活，它避免了pipe必须一端读一端写这个弊端，而且只创建了一个文件描述符，pipe必须创建读写两个文件描述符。eventfd的性能要比pipe要更好。

### 使用

pipe和eventfd都有一个非常巧妙的设计，就是可以与select、poll、epoll配合使用，以达到监听数据传输的目的。

这里以eventfd做讲解，eventfd本身并没有提供监听的功能，也就是说，计数器的数据被改变时，引用这个eventfd的进程并不会收到通知。但Linux在推出eventfd机制的时候，就已经设计好其可以和select、poll、epoll配合使用。这三个系统调用可以用来监听某个文件描述符（常指向的是一个socket，但这里是eventfd的计数器）中的数据，它们使用的时候需要传入一个封装的文件描述符用来指定监听目标，而eventfd创建时所返回的文件描述符正好可以传进其中。

eventfd经常会和epoll一起出现，在Android消息处理机制中，监听是否有消息传入用的机制就是eventfd+epoll。
