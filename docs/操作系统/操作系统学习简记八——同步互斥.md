# 操作系统学习简记八——同步互斥

## 目标

在允许并发执行的同时，保证一些操作是原子操作。

## 概念

### 互斥

一个进程占用资源，其它资源就必须等待

### 死锁

循环等待

### 饥饿

进程轮流占用资源，一个资源一直得不到资源

### 临界区

需要保证进程互斥的区域

### 进入区

即将进入临界区的区域，需要在此处做互斥处理

### 退出区

临界区结束的区域，需要做锁释放

## 访问规则

* 空闲则入
* 忙则等待：临界区有进程了，就不能进入
* 有限等待：不能无限等待
* 让权等待（可选）：暂时不能进入临界区的进程，应该释放CPU

## 实现方法

### 禁用中断

没有中断，没有上下文切换，没有并发。但会导致中断没有处理，一切中断都会延迟到中断被启用之后才会处理。这个一般由体系结构提供指令来实现。

### 软件实现

手动做while和标记位的处理。

* 先做判断，后做标签：可能两个同时先做判断，然后再进入，贴标签。
* 先贴标签，后做判断：可能导致两个都进不去。
* 先申请进入，再打标签，再同时判断申请和标签，可以完成。Peterson算法。

### 高级抽象（硬件）

#### 锁

一个抽象的数据结构，由一个二进制变量（标记锁定和解锁）、一个Acquire行为、一个Release行为组成。

* Acquire：锁释放前一直等待，然后得到锁
* Release：唤醒所有正在等待的锁

基于原子操作指令，包括测试置位、交换指令。

#### 信号量

和软件实现稍微不同，引入操作系统作为管理者。

由一个整型共享变量（记录共享资源数）和两个原子操作组成。

* P()：sem减1,如果小于0,进入等待，否则继续。
* V()：sem加1,如果sem<=0，唤醒一个等待进程，因为说明有线程在等待。

事实上类似软件实现，但由操作系统保证其原子性。

#### 管程？？

* 任一时刻只有一个线程执行管程代码。
* 与临界区不同的是，正在管程中的线程可以临时放弃管程的互斥访问。

## 死锁

### 处理方法

* 预防：打破死锁的必要条件，如在进程申请资源时，将其所有持有的资源释放。
* 避免：先判断是否会出现死锁，不会再分配给你。确保不会出现环形等待。

#### 银行家算法

判断自己的资源是否足够能满足请求，如果不能满足的话，直接拒绝。

首先判断线程整个流程需要的最大资源，减去已分配的资源，可以得到还需要多少资源。此时和当前可用资源做比较，如果存在可以完全满足的线程，就分配给它，则它执行完之后，可以回收其占用的资源。由此迭代可以得到安全序列。

#### 死锁检测

允许系统进入死锁，定期检查，如果出现死锁，则调用恢复机制。
