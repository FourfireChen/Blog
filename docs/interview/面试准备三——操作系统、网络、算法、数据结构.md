# 面试准备三——操作系统、网络、算法、数据结构

## 操作系统

+ 进程线程
+ 同步
+ 内存管理
+ 中断、异常
+ 启动流程
+ IPC：eventf vs pipe
    + pipe：两个文件描述符，单项流动。分无名管道和有名管道
        + 无名管道：通常建立于父子进程或兄弟进程之间，有名管道以文件的形式，供打开者共享。
    + eventfd：一个文件描述符
+ IO：
    + 阻塞IO在数据没到达时阻塞用户进程，非阻塞IO会返回error，需要用户进程轮循。
    + 多路IO复用，同时监听多个文件
        + select：封顶1024个fds，从用户空间拷贝给内核，内核不停对fds轮循，没有事件则阻塞用户进程，有事件则唤醒用户进程，但不知道是哪个fd的事件，所以每轮需要对所有fds遍历。
        + poll：解决了1024问题，其他的和select一样。
        + epoll：
            + 解决拷贝问题：采用内存映射，内核返回给用户空间的空间，直接映射到用户空间中。
            + 完全遍历：添加了中间层，用户进程睡眠在中间层，而内核接受到事件时，只把有事件的socket封装发给中间层，用户进程就不需要每次都完全遍历了。
    + 信号驱动IO：半阻塞，用户进程read之后直接返回，内核准备数据完成之后，通知用户进程阻塞，再复制传递数据。
    + 异步IO：完全不阻塞，read之后直接返回，内核数据完成之后直接复制传递数据，再发送信号通知用户进程。

## 网络

+ 五层协议
    + 应用：http、ftp等
    + 传输：TCP、UDP
    + 网络：IP
    + 链路
    + 物理
+ TCP和UDP
+ TCP三次握手、四次挥手、为什么？
    + 建立链接：Client发起，告知要建立，Server确认可以建立，Client再确认，而这个包似乎已经可以带点数据了。这么做的目的主要为了防止server一直等待，因为Client发送的第一条请求可能会延迟，此时如果延迟到超时才到达server，那么server确认后就会一直等待，而client却不想发送了。所以需要第三个，server等不到第三个就关掉，因此不会浪费。
    + 断：C/S都可以主动，而主动方要告知被动方，我的数据已经传输完了，被动方返回确认。此时主动方继续等待，被动方数据发送完之后，会告知主动方，因此主动方再次确认。这个和读写分开有关，现在的TCP似乎是读写分开的，断的时候，主动方发送通知，被动方关闭读，返回一个确认，主动方关闭写。后面也一样。
+ https的改进：
    + http明文传送，https用ssl加密

## 数据结构/算法

+ 快排

+ 堆排

+ LRU、Clock

+ 链表翻转

+ B树、红黑树

+ 动态规划：建立于子问题的最优解上，再添加一点点内容
  + 硬币问题：1、3、5面值，初始化1、3、5需要的数量，而其他的数量，则在i-1，i-3，i-5上增加1，然后**取最小值**即可。
  + 最大连续子序列和：
    + 动态规划法：假设一个数组sum，sum[i]记录的是数组a[0]-a[i]的最大连续子序列和，那么sum[i+1]的最大连续子序列就是sum[i]和0的大者，如果a[i+1]>0则加上，否则不变。
    + 分治法：左、右和中间的最大值，左右靠递归，中间算法是从中间向左、右算出去，取最大的，加起来。

+ 数组查找题：注意其范围和大小的关系，可以主动想想中位数的应用。

+ 数组赋值题：为了避免从头到尾复制的移动，可以从尾到头。

+ 自上而下的解法常会有重复计算，可以转为自下而上。

+ 回溯法解决问题时，一般把状态看成节点，把选项看成连接线。

+ 动态规划：

  + 从上往下分析问题，从下往上解决问题。

  + 从下往上时，记录重复的中间结果，如以数组的形式，记下所有子问题的最优解。也有可能是二维数组，二维动态规划，如礼物问题。

+ 要时刻记得考虑周到：如负数、0、边界、大数、浮点数不精确
  + 数值的整数次方：要考虑负数、0。同时可以采用分奇偶的方法，时间复杂度降为logn
  + 打印0-n的数：要考虑大数，直接打印会溢出。
  + 删除节点：要考虑头和尾
+ 树遍历结果相关的题：分为根节点、左子树部分、右子树部分，递归。