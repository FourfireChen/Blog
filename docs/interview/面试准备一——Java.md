# 面试准备一——Java

## 基础

+ Arrays.copyof和System.arraycopy:
    + copyOf调用了arrayCopy
    + copyOf接受一个数组，返回一个新数组
    + arrayCopy接收两个数组，把第一个拷进第二个
    + 使用了mmmove系统调用，直接在内核中进行内存拷贝，性能高
+ 多态
    + 主要涉及方法和变量的主体的确定，有两种绑定方法，动态绑定和静态绑定
        + 静态绑定：程序编译期间就确定下来的方法/变量。final、static、private修饰的方法、构造方法、成员变量。
        + 动态绑定：程序运行期间才会动态确定主体的方法/变量。
    + 静态绑定出的主体是其声明的主体类型；动态绑定的主体是真正的对象，其确定顺序是先子类再父类。
    + 重载是静态，重写是动态
+ String
    + final类
    + 其实是封装的char数组
    + 一旦创建，任何操作都不会改变其值，而是新建一个String
    + 字符串常量池：字面量（常量）会使用常量池，如果是new出来的会直接放在堆中。
    + new String("")。这段代码创建了一个对象，涉及到两个对象。因为常量不是在这时创建的，而是在类加载的时候就创建的。
+ StringBuffer、StringBuilder
    + Builder非线程安全，但快
    + 类似ArrayList的扩容
    + +号使用Builder拼接，一次+拼一个，性能开销大
+ equal和==：比较值和比较址
+ 反射的原理、反射性能问题
    + 定义：在java程序运行过程中，对任意一个类都能知道其属性和方法；对任意一个对象都能调用其方法和属性。
    + 原理：Java文件被编译成class文件，每次有新的类加载的时候，虚拟机会通过Classloader加载类，在堆中创建一个class对象，这个对象记录了类对应的各种信息，包括常量、方法等等，反射就是利用这个Class类来动态操作。
+ 动态代理：Java的reflect提供了一个Proxy和InvokeHandler类，内部通过反射动态生成实例，而且这个实例是某个对象的代理，通过重写InvokeHandler的方法，可以对原对象的方法进行代理。
+ 注解：注解是给编译器看的，编译器会把注解信息写入class文件，在运行时，通过反射，获取Class对象，可以获取其中的注解信息。
    + 自定义注解：元注解就是负责注解其他注解，用来定义注解，可以指定修饰范围、保留时间（如编译器丢弃、运行期）、文档、继承等等。
        + 使用@interface自定义注解接口，该接口自动继承Annotation。
    + 相当于打了个标记，所以在运行时，就可以获取到。
+ 深拷贝、浅拷贝：
    + 浅：基本数据值传递，引用数据引用传递
    + 浅拷贝：基本数据值传递，引用数据创建新对象
+ final
    + 因为外部类的局部变量可能销毁，而内部类没销毁，所以必须final，变成常量存在常量池中。
    + 但JDK1.8之后，如果读可以不final，因为编译器会把该值编程匿名内部类的成员变量，然后从构造方法放进去。
    + 然而有个前提是读了，其他地方没有写。
+ Java动态，如Option

## 集合框架

+ ArrayList、LinkedList：
    + ArrayList默认大小10,不足时拓到1.5倍。LinkedList是双向链表，由一个不存数据的header引领。
    + 都实现了Cloneable、Serializable接口
    + 非线程安全，多线程下可以使用Collections.synchronizedList返回一个线程安全的ArrayList或者使用CopyOnWriteArrayList。
+ CopyOnWriteArrayList和synchronizedList
    + SynchronizedList就是给大部分操作加上锁，但是迭代器还是没锁。
    + CopyOnWirteArrayList就是在add的时候，每次都新开一个数组，然后再把引用设置好。
+ LinkedHashMap：迭代顺序是插入顺序
    + 本质上是HashMap和LinkedList的结合，插入节点时，除了保存进散列表，还会保存进一个双向链表。
    + 可以方便地实现LRU，LRU的最大开销就是查找有没有已存在的，而结合了散列表则可以在常熟时间内找到。
+ HashMap原理：put、get、扩容、并发问题
    + 原理：

        + 容量是桶数，负载因子是调整的阈值，默认0.75，调整倍数为2。

    + 多线程解决：synchronizedMap也是对操作加锁，ConcurrentHashMap

    + 1.7 vs 1.8：

        + 引入红黑树
        + 存储流程变了
        + 节点实现类改名字：Entry->Node、TreeNode
        + 1.7：先扩容，再插入

    + put过程：

        + hash：

            获取hashCode，做扰动，然后&(length - 1)获得下标。扰动函数1.7和1.8不同。

            > 为什么数组长度要是2的幂？
            >
            > 1. 为了保证HashCode在数组大小范围内，必须取模，而取模运算效率低，如果2的幂，可以使用&(length - 1)达到一样的效果。
            > 2. 2的幂是偶数，则length - 1是奇数，只有这样才能保证&(length - 1)的结果最后一位有0有1，如果反之，会全是0
            >
            > 为什么要扰动？
            >
            > 1. 保证随机性。

        + 获取hash值之后，存储过程：

            + table是否null，如果是，初始化table。

            + 根据hash计算下标。

            + 看是否发生冲突，如果不冲突，存入，完成；若冲突，继续往下。

                + 如果table[i]的键刚好就是，直接更新；否则往下。

                + 如果是红黑树，遍历红黑树，插入或更新。

                + 如果是链表，遍历链表，看看有没有相同。如果有，更新。如果没有，尾插，然后看是否要转换成红黑树，再看看是否要resize（判断依据是**所有元素**的数量大于阈值）。

                    > 判断规则是：如果链表长度大于8，并且table长度大于阈值。若是大于8，但长度小于阈值，只需要resize就好。

            + 扩容（1.7 vs 1.8）：

                + 2倍扩容新建数组。
                + 遍历旧数组，计算存储位置：
                    + 1.8：原位置 or 原位置 + 旧容量
                    + 1.7：全部按hash算
                + 逐个转移数据：
                    + 1.8：尾插。避免了并发环形链表死循环问题。
                    + 1.7：头插。可能会有死循环。

    + 并发问题：

        + 1.7会出现环形死循环。
        + 无加同步锁保护：主要是在put的时候，假设线程１计算好，找到table，并且为空，当此时它让开了，线程2找到同一个table，然后直接完成所有工作，再到线程1时，会把线程1的值覆盖掉，而不是插入。
        + 迭代器fail-fast：就是在迭代器遍历的时候，并发修改结构。

    + 并发解决：

        + HashTable暴力对所有操作加了同一把锁。

        + synchronizedMap，也是暴力加锁。

        + ConcurrentHashap：

            + 1.7：二级哈希表。一级是segment数组，一级是hashentry数组。Segment继承可重入锁（线程拥有该锁时，可以直接调用其他需要该锁的操作）。以此将锁的粒度减小，提高效率。则理论上并发度和Segment数组大小相等。

            + 1.8：取消了Segment的结构。包含了Node数组，Node对象包含K、V以及下一个Node对象。用CAS（比较并替换）解决并发问题。

                > CAS：三个操作数：内存地址V（真实的值）、旧的预期值A（没有并发问题时应该的值）、目标值B。只有V和A的值相等时，也即没有其他线程更新过时，才会更新B。

                + put过程：
                  + 如果没有初始化，初始化。
                  + 如果没有Hash冲突，直接CAS插入。
                  + 如果还在进行扩容操作就帮助扩容。
                  + 如果存在冲突，加锁插入。后面和hashmap一样。

                因此加锁的部分只是存在冲突的部分，也就是一个桶，粒度减小到一个桶。

+ TreeMap：基于红黑树构造，是特殊的二叉查找树，所以迭代的话其顺序是按照key的大小来的。

## JVM

+ 内存模型：
    + 方法区：储存类信息、静态变量、常量等等，线程共享。
    + 堆：存放对象实例，是GC的主要目标，线程共享。
    + PC
    + 虚拟机栈：线程私有，JVM默认是基于栈的，就是没有寄存器的概念

+ 内部类和匿名内部类都会编程.class文件

+ volatile：

    Java内存模型中，变量都会存在主存上，而线程不能直接访问主存，而是通过一个线程私有的工作内存。工作内存用于缓冲主存，所以会有不一致的问题。

    + 保证有序性，禁止指令重排序。
    + 保证可见性：保证修改的值立即刷新到主存中。

+ 对象锁和类锁：Java的锁默认是互斥锁
    + 对象锁：多个线程访问多个实例的时候，互不干扰，锁不同。
    + 类锁：可以锁住多个线程，相当于一个全局锁

+ run和start的区别：start才是真正的多线程

## 设计模式

+ 单例

    + 饿汉：在类加载时就完成初始化

    + 懒汉：在第一次调用时才初始化，可以加锁

    + 双重检查：避免了不必要的同步

        ```java
        private volatile static Singletion instance;
        public static Singleton getInstance() {
            if(instance == null) {
                synchronized(Singleton.class){
                    if(instance == null) {
                        instance = new Singleton();
                    }
                }
            }
            return singleton;
        }
        ```

        + 第一个if是为了避免每次调用该方法都要经过synchronized，第二个if是避免在初始化的时候，多个线程同时通过第一个if

        + volatile：使instance对象具备有序性。创建对象的指令有三步，开辟内存、堆上初始化、返回引用，其中后两步是可以重排序的，如果后两步颠倒，有可能第一个线程先返回应用，然后初始化一半，第二个线程发现不是null，就返回了，会出问题。

    + 静态内部类：内部类的加载是在使用时

+ 桥接

+ 责任链

+ 装饰器

+ 代理

+ 策略