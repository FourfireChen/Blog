# 项目

## 青蛙记账

+ 自定义View：自定义ViewGroup，把目标锚点包起来，然后在ViewGroup中获取到子View的大小，点击时，在子View的指定幅度大小内，用属性动画移动若干个气泡，translateX。



## V2EX

+ HTML解析主要抓住DOM树，而且需观察其特征。
+ butterknife：在bind的时候，将传入的this解析，通过反射拿到其注解的变量和方法，然后设置。
+ okhttp：线程池？多个请求，如果是同步的，当然就



## 传送门

+ 布局优化：viewstub，用在了详情页的下面的按钮，这个做了Activity，可以重用，但是按钮样式和文字不同，而且数量不同，所以每次如果有viewstub就再展开。merge是
+ 保活：



## Binder

+ 主要包含Client、Server、ServerManager和binder驱动

### Binder驱动

+ 启动：由init进程启动，和其它Linux驱动一样是以misc文件的形式存在的，init进程打开文件，然后为其分配一个内存空间，然后通过ioctl来和其交互。
+ 负责开辟一片物理空间，然后映射到内核和用户空间。

### 通讯过程

+ Client发请求给驱动，驱动返回收到，Client休眠
+ 驱动向Server请求，Server返回数据，驱动返回收到，Server休眠
+ 驱动返回给Client

### 内存机制

+ Client的用户进程空间的区域拷贝到内核空间，而Server的用户空间中有一段会映射到这片内核空间，所以可以直接获取了，于是Server就不需要拷贝了。

### ServerManager

负责查询和注册服务，本身也是一个Binder服务

+ 启动：由init进程启动，open打开binder设备，通过ioctl告诉驱动自己是管理者，分配空间，映射，然后进入循环等待Client请求
+ 注册：根据注册的服务的请求名称，检查，然后接收handle信息，保存起来。
+ 查询：通过服务名查询相应的handle信息
+ 获取：
  + 不同进程：请求服务所在进程创建
  + Client调用获取方法，会打开驱动设备，mmap映射，然后通过handle=0获取到ServerManager
  + 

### 使用

+ 定义接口继承IInterface，定义Service继承Binder实现接口
+ 重写asBinder，asInterface，onTransact和自定义方法。asBinder返回this，asInterface通过参数传进来的obj可以查询本地的实现接口，返回；onTransact负责获取Client传过来的参数，以及调用真正的实现方法。

### 整个流程

+ 注册服务：AMS注册到ServerManager，AMS是客户端，ServiceManager是服务端，
+ 获取服务：Client向ServiceManager获取AMS的代理
+ 使用服务：通过AMP与AMS通讯，AMP是客户端，AMS服务端。
  + 创建Parcel，然后把传递的参数写进去，然后调用Binder的接口传递，然后等待结果。
  + 陷入native层，转换成BpBinder的transact方法，向mOut写入参数，循环等待mIn。
    + mOut写入是通过ioctl跟Binder驱动通讯，驱动将数据拷贝到内核空间，然后唤醒目标Server进程执行事务。
    + 监听内核空间那片区域，直到有数据，就搬回来，写回用户空间，一直返回出去
  + 而服务端，在初始化时需要创建Binder线程，加入Binder线程池，这些线程会一直尝试读取数据，如果读到了协议，就返回来执行。
+ 关于线程，通过Binder的Server在Binder线程池中执行，一般程序由Zygote进程fork出来之后，都会创建一个Binder线程池，然后有一个Binder主线程，这个时必须的。然后其它的由Binder驱动返回来的时候，根据有没有空闲的线程，有的话就送到那执行，没有的话就创建咯。