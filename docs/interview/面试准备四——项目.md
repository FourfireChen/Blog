# 面试准备四——项目

## 青蛙记账

+ 悬浮窗实现：
    + 获取WindowManager
    + 申请权限SYSTEM_ALERT_WINDOW
    + LayoutParam的type类型：
        + 8.0之前，直接使用TYPE_PHONE
        + 8.0之后，使用TYPE_APPLICATION_OVERLAY
    + 用Service来开启，让悬浮窗与Activity分离
    + 拖动功能可以通过WindowManager.updateLayoutView实现
+ 悬浮窗获取点击事件：使用FLAG_NOT_TOUCH_MODAL，就可以edittext弹出输入法，但会导致不在窗口范围内的地方也接收不到事件，于是就在输入完成的时候，重新换回FLAG_NOT_FOCUDABLE，但flag是不允许动态改变的，所以只能把原View删除，然后重新添加，这样又会导致闪烁，所以很难受。
+ WindowManagerImpl调用了global，桥接模式，创建了viewRootImpl、view、param，然后调用session，这是Client端代理。一个进程一个session。此时WMS会给窗口分配surface，确定显示次序，而显示就不是WMS的职责了。
+ 自定义View：继承ViewGroup写的，包住一个锚点，动态添加或静态添加按钮的数量，大小确定死的，onMeasure重写不困难，onLayout调用addView，以及注册他们的点击事件，对外提供点击。锚点接收到点击的时候，使用

## 传送门

+ okHttp：

    + 基础使用：创建一个Client，创建一个Request（制定URI、接口、参数等），调用client.newCall获取一个Call，调用execute可同步获得response，调用enqueue可以异步获取response。

    原理：

    + 创建Client时使用的是new一个Builder传入，扎堆配置。
    + newCall时创建一个RealCall，调用时有两种
        + 异步：以Dispatcher分发，给线程池。线程池是一个核心线程为0，非核心线程不限制的。
        + ￼同步：直接调用获取结果
    + 获取结果的代码是okhttp设计的精髓，使用了过滤器，先把过滤器添入一个List中，连成一条链，然后通过责任链模式，递归调用，一直分发下去。
    + 首先是重试和重定向interceptor，会一直循环获取后面链的结果，会处理重定向，直到成功或者失败。
    + 然后是Bridge，对request做封装，比如拼接header，如果用户指定了则拼接，没指定就默认。继续发送。对结果也会处理。
    + 缓存interceptor，如果无网络且有缓存，返回；如果有响应，更新缓存。
    + 新建一个http连接对象，然后获取链接，交给下一个过滤器。这里的获取逻辑是连接池，Okhttp也会对连接做缓存，同一个host的链接可以复用。
    + 写入请求，发送请求，获取响应，构造响应

+ retrofit：是对okhttp的进一步包装。

    + 创建：建造者模式创建，传入URL、Adapter、Convertor、要解析的类等等。这里会配置网络请求工厂、请求适配器、返回转换器以及okhttpClient等等。
    + retrofit.create创建代理过的接口，使用了动态代理，对原方法的注解拿出来解析，然后放入serviceMethod中，然后交给重写的okHttpCall处理，并把得到的结果通过用户传入的Adapter进行适配。
    + 调用方法后会获取到Call，这个Call其实是okHttpCall，它的返回过程会调用Conventer进行转化，得到要的结果再返回。