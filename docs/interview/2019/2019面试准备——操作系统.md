# 2019面试准备——操作系统

## 进程线程

+ 进程：操作系统对运行空间的抽象，是资源分配单位
  + 在内核中对应一个PCB
  + 运行->就绪->等待（阻塞）
  + 挂起：不占用内存空间（阻塞占用）。该进程的所有内存空间被暂时交换到硬盘中
  + fork->exec->wait->sleep->exit
+ 线程：操作系统对执行的抽象，是CPU调度单位
  + 对应一个TCB
  + 实现方式
    + 用户线程：在用户空间实现，由应用程序管理
      + 一进程只能一CPU：内核不知道线程的概念
    + 内核线程：在内核实现，由内核管理
      + 由内核管理线程
      + 创建管理调度等都要在内核
    + **轻量级进程**：用户空间操作线程，每一个线程和一个内核线程映射
+ Linux下使用轻量级线程：内核中，线程和进程都用的task_struct来描述，进程有对应空间，线程没有

## 同步互斥

+ 同步：对不同线程的执行顺序做出规定
+ 互斥：对统一资源保证独占性
+ 常见方法
  + 信号量：同步。维护一个共享资源数，PV操作
    + P：sem-1，如果小于0，等待，否则继续
    + V：sem+1，如果<=0，唤醒一个等待线程
  + mutex锁：互斥。一个标记位，获取和释放操作

## 系统启动

+ 系统加电，读取闪存中的BIOS到固定内存空间运行
+ 硬件检测
+ 加载硬盘中的BootLoader（一般放在第一个主引导分区）到固定内存空间运行
+ BootLoader找到硬盘中OS内核，载入内存，然后切换上下文（PC），操作权交给内核

## 调用、中断、异常

+ 调用：应用程序请求
  + 同步或异步
  + 通过系统调用接口
+ 中断：外设或某些设备对处理器的消息通知（应用程序无感知）
  + 异步
  + 处理
    + 保存现场
    + 根据中断号找到程序，执行
    + 恢复现场
+ 异常：非正常处理
  + 同步
  + 处理与中断相似

## 内存

+ 逻辑地址：应用程序拥有的内存范围
+ 物理地址：硬件
+ 分页分段：解决非连续地址分配
  + 分段：**按用途分为各种段，如数据、代码等**。段寄存器和偏移寄存器
    + 段号->段表（操作系统管理）->段首地址、长度
    + 偏移地址+首地址=物理地址
  + 分页：**划分为固定大小**
    + 物理内存划分为**帧**，逻辑地址划分为**页**
    + 页号->页表->页帧号->偏移地址->物理地址
    + 优化
      + MMU：缓存近期访问的页帧转换项
      + 分级页表
+ 虚拟内存：基于分页分段、交换技术
  + 内存外存的交换，粒度为页或段
  + 基于局部性原理：时间、空间
  + 发生缺页则产生缺页中断，从外存调入
  + 各种队列管理方式进行优化页置换

## IPC

+ 管道：两个文件描述符，单向流动，一个读一个写。分无名和有名管道
+ 信号：类似软中断，发送信号通知进程，异步处理。由信号处理函数单独处理
+ 共享内存：基于分页机制，同一块物理地址映射到不同的页表中
+ 消息队列：单向流动
+ Eventfd：一个文件描述符，读写均可。维护一个计数器。

基于文件的管道和Eventfd，均可配合IO，实现监听

## IO

Linux下的IO默认都是缓存IO，会经过内核的缓冲区。内核对缓冲区进行监控管理，保证可控。

注意阻塞和非阻塞、同步异步，不是同一个概念：阻塞非阻塞是对进程线程的状态管理，而同步异步指的是逻辑上的顺序。

+ 阻塞IO：用户进程被阻塞
+ 非阻塞IO：用户进程不阻塞，但需要轮询
+ IO多路复用：多路指的是同时监听多个描述符，复用指的是使用一个线程来监听并执行对多个描述符的IO操作
  + select：用户空间拷贝目标描述符（封顶1024个）给内核，内核挨个监听。有事件到来，内核唤醒用户进程，用户进程需要挨个尝试获取
  + poll：只加大了1024
  + epoll：增加了中间层，按需遍历
+ 信号驱动IO：read后不阻塞，数据准备完成后内核通知用户进程阻塞，由用户进程通过系统调用再获取数据。
+ 异步IO：read之后不阻塞，数据准备完成之后，由内核完成数据从内核空间到用户空间的拷贝，然后再通知用户进程取数据。

## 文件

+ 文件描述符：文件的相关信息。存在内核的文件表中，一个进程一个文件表
  + 包括文件指针（读写位置）、文件位置、访问权限等等
+ 文件系统
  + 树。目录也是一种特殊的文件