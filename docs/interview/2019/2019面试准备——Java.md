# 2019面试准备——Java

## 基础

+ 多态：语言特性，用同一借口访问不同的具体实现，使得不同的实现的使用看起来是相同的
  + 方法和变量的主体的确定
    + 静态绑定：编译器确定主体
      + final、static、private修饰的方法、变量
      + 主体是声明的类型
    + 动态绑定：运行期间才能确定主体
      + 主体是真正的对象，确定顺序是先子类后父类
  + 重载是静态，重写是动态
+ StringBuffer、StringBuilder：Builder快但线程不安全
+ 反射：新类加载时，JVM通过ClassLoader加载，在堆中新建一个class对象，记录了类的各种信息，反射就是使用这个class对象来动态操作
+ 注解
  + 源码级（source）：完全和运行无关
  + 编译级（class）：存在于class文件中。只在编译期存在，运行时会被丢弃
  + 运行级（runtime）：运行时存在

## 集合框架

### List

+ ArrayList
  + 默认大小为10，不足扩大到1.5倍 + 1
+ LinkedList
  + 双向链表。节点是内部类Node。
  + 实现了Deque

### Map

#### HashMap

+ 拉链法：数组+单链表

+ 1.7
  + 插入
    + 如果需要则初始化table
    + 获取key hash、index
      + 冲突
        + 找到是否equal存在，如果是，更新返回
    + 插入
      + 如果size（当前的所有数据的数量）>=阈值（**长度*负载因子**）且要插入的链表不为空（冲突），扩容，重新获取hash、index
      + 头插
  + 并发问题（https://juejin.im/post/5a66a08d5188253dc3321da0）
    + 由于头插，会将链表反向
    + resize的transfer：扩容后重新分配已存在元素
      + 线程1已赋值e、next，线程2接管并将链表反转
      + 线程1处理完e、next，则table[i]已经是next
      + 再处理next，即原来的e，头插，会调用e.next = table[i]，形成循环

+ 1.8：引入红黑树（TreeNode）、改为尾插、Entry->Node、扩容后位置单独处理、初始化表统一resize处理

  （https://juejin.im/post/5aa5d8d26fb9a028d2079264）

  + 插入

    + 如果需要，初始化table
    + 获取key hash、index
    + 如果table[index]null，直接放入
    + 找到对应的坑位
      + 如果是树，若存在，覆盖值，若不存在，插入
      + 如果是链表，若存在，覆盖值，若不存在，**尾部**新建节点，并判断是否要树化（链表长度>8）
    + 如果size>阈值，扩容

  + 扩容：由两种情况，1初始化，2太小扩容

    + 计算新容量

      + 情况2：如超过最大值，则按最大值，否则扩容为2倍
      + 情况1：默认值或指定值

    + 把原节点移动到新bucket中，尾插

      > 位置计算与1.7不同
      >
      > 1.7：按原方法计算，左扰动处理后取模
      >
      > 1.8：原索引或者原索引+原长度

#### LinkedHashMap

迭代是有序的。在维护Map的时候，同时维护一个双向队列

#### SparseArray

key为int的map，Android特有。key是有序的，存在一个数组中。查找的时候可以二分

### 并发

#### List

正常List迭代过程中不允许修改数据，这是语言特性：维护了一个modCount，每次操作会变动，迭代时检查该值。

List并发下会导致错位，以及部分元素为null，因为使用了size作为下表，而且同时++操作

+ CopyOnWriteArrayList
  + 所有的修改操作都改成了对现有array的复制，然后在复制对象上操作，再设置回去。
  + array使用了volatile关键字修饰，**保证了对变量修改的线程可见性**
  + 修改操作加锁（一个专用的Object变量），保证线程安全

#### Map

+ ConcurrentHashMap

## JVM

### 内存模型

+ 线程通讯
  + 一般有共享内存和消息传递两种，Java使用的是共享内存，Dart使用的是消息传递
  + 每个线程抽象了一个本地内存，相当于主存的副本，进行缓冲以及各种优化。这种JVM的抽象也映射到硬件架构中内存-CPU缓存
+ 内存分为堆和栈，每个线程一个栈，共享一个堆
  + 本地变量保存在栈中，其中原始数据类型直接保存，引用类型保存了引用，指向堆中的对象信息
  + 对象的成员变量都在堆中（包括原始数据类型变量）
  + 更仔细的划分为
    + 堆：堆区、方法区（Class对象、静态变量、类中的常量和方法、常量池）
    + 栈：JVM栈、native栈：一个方法调用开一个栈帧，存局部变量等等
+ 对象布局
  + 对象头
    + Mark Word：标记位，如HashCode、分代年龄、指向锁的指针等等
    + Class Pointer：指向对应的Class对象
    + Length：如果是数组对象，还有一个保存数组长度的空间，4字节（所以最长2的32次方）
  + 实际数据
  + 补齐：8字节对齐

### GC

+ 查找算法

  + 根搜索
  + 引用计数

+ 流程

  + 标记：标记不可清扫的对象

    > GC Root对象：
    >
    > 1. 栈中引用的本地对象
    > 2. 方法区常量
    > 3. 方法去静态变量
    > 4. 栈中native方法引用的对象
    > 5. 活跃线程

    + 标记前需要暂停线程（stop the world），到达安全点

### 并发

+ 乐观锁：假设操作时没有并发问题，不上锁，但更新时需要判断有没有其他线程进行了修改。一般使用**版本号**或**CAS（Compare and Swap）**实现。如concurrent包中的AtomicInteger等

  悲观锁：synchronize、lock。假设有并发问题，不能同时执行，直到锁释放。

  + CAS：用当前线程的变量和内存中的真实变量进行比较，如果相同则写入（真实变量没有被其他线程修改，不需要同步），不同则放弃（一般手动循环重新获取内存中的值，为保证可见性，该值一般也是volatile）

    > ABA问题：原值A，线程2修改为B，再修改为A，线程1比较的时候发现没有问题，但实际上可能会有问题。可用**版本号**标示控制

  + 写的多的情况用悲观锁，避免乐观锁大量的循环询问。读得多的情况用乐观锁，可减少锁竞争

+ volatile

  + 可见性：读取会去主存读取更新缓存，写入会强制刷新到主存

    > 线程抽象使用单独CPU，CPU有自己的高速缓存，正常情况下为主存的副本，但读写无法保证及时刷新到主存中，可能导致数据不同步问题

    + 单例双重加锁模式
    + 只能保证读到最新的内存中的值。但如果操作为：读、改、写入，而两个线程同时读取，那就没办法了，也会造成同步问题。（**不保证原子性**）

  + 有序性：对volatile变量的读写操作，其前面的语句一定在前面，后面的语句一定在后面

    **在做标记位的时候注意**

    ```java
    //线程1:
    context = loadContext();   //语句1
    inited = true;             //语句2
     
    //线程2:
    while(!inited ){
      sleep()
    }
    doSomethingwithconfig(context);
    ```

    主要担心这种情况，如果语句2被重排序到1前方，会导致没有初始化而下面判断初始化了

  + 原理：对读写操作，从汇编代码的层面上添加了lock前缀，增加内存屏障

    + 可见性：写操作后增加写入屏障，保证cache刷入主存；读操作前插入读取屏障，保证读取主存
    + 有序性：对JVM来说，内存屏障指令不允许前后重排序，所以保证了有序性

  + 使用场景（https://blog.csdn.net/vking_wang/article/details/9982709）

    + 标记位：可见性和有序性均需要得到保证
    + 单例双加锁：避免instance赋值之后，其他线程看不到而又赋值了一遍
    + 读写模式：写必须同步，但读只需可见，可允许多线程
    + 多线程访问的bean

+ synchronize：

  + 原子性

  + 可见性
    + 加锁->更新主存到缓存->执行代码->更新缓存到主存->释放
    + **无法保证其他线程读取的时候，一定去主存中读**：这就是为什么读取操作也要加锁，保证去主存中读。但没必要，可以使用volatile，在这方面sychronized明显比volatile要不方便
    
  + 原理

    + 重量锁

      + Mark Word中存有指向锁的指针，锁是一个monitor对象，由JVM实现

        > 一般monitor中记录了等待队列、运行线程、获取次数等等信息

        + synchronized块
          + `monitorenter`获取对象锁持有权，如果count==0或重入，可成功，count++。如果不成功，阻塞
          + `monitorexit`释放锁，count--，通知其他线程
          + 一般会有两个monitorexit，第二个是处理异常的
        + synchronized方法
          + 方法表中的方法添加一个`ACC_SYNCHRONIZED`标记位，流程与块相同

      + 重量级锁依赖于mutex（互斥锁），需要用户态和心态的上下文切换，消耗大

    + 1.6优化

      + 自旋：不是马上挂起，而是少次数循环，尝试获取。并且这个次数会照前面线程的情况自适应。针对重量级锁和轻量级锁进行优化。

      + 锁消除：删除不必要的同步，如非共享元素的同步处理

      + 锁升级：偏向锁 -> 轻量级锁 -> 重量级锁：偏向锁和轻量级锁都是一种乐观锁

        + 偏向锁：**假设只有一个线程在访问该区域，一旦出现第二个线程，升级。**优化：乐观、减少内核态上下文切换开销

          获取：Mark Word中偏向锁线程ID是否指向当前线程，如果是，直接执行；不是则进行初始化CAS，成功则设置线程ID，失败则说明不止一个线程要使用该锁，挂起并升级为轻量级锁。

          释放：有竞争才释放，等到全局安全点，释放，升级

        + 轻量级锁：**假设可有多个线程访问该区域，但不会出现竞争，或者竞争极小（自旋可以解决）**优化：从多次CAS降低到一次CAS

          每个线程栈中维护一个Lock Record

          获取：对Mark Word中的轻量级pointer进行CAS（应该是判断是否有线程正在使用）更新，指向本线程Lock Record，成功则获取（标记该锁我正在使用），失败则自旋，再失败则升级。

          释放：恢复Mark Word中的pointer

+ Lock：1.5之后添加的，为了使锁更灵活。简单使用就是`lock.lock()`和`lock.unlock()`

  + ReentrantLock：互斥锁，只允许一个线程访问。相当于synchronized

    + Condition：实现`wait`、`notify/notifyAll`机制

      + 创建：`lock.newCondition()`
      + 使用：`condition.await()`（== `wait()`）

    + 与synchronized区别

      + 一个Lock可有多个Condition监听，可选择性唤醒

        synchronized相当于只有一个synchronized，notifyAll全部唤醒，notify由cpu选择唤醒

  + ReentrantReadWriteLock：读写锁，解决读写模式性能底下问题。

    + `lock.readLock().lock()`、`lock.writeLock().lock()`
    + 读锁之间不互斥，读锁写锁互斥，写锁写锁互斥
    + 事实上读锁只是为了保证可见性，**类似于使用volatile**

  + 与synchronized区别（https://juejin.im/post/5a43ad786fb9a0450909cb5f）

    + 可重入：本线程已获得锁的情况下，再执行到lock不需要再一次获得锁，继续执行。synchronized和lock均可重入
    + 阻塞
      + synchronized一定阻塞
      + Lock调用`lock()`时阻塞，使用`tryLock()`如果失败直接返回
    + 可中断：在等待锁的过程中是否可响应中断
      + synchronized不可中断
      + Lock调用`lock()`不可中断，调用`lockInterruptibly()`可中断
    + 公平：非公平则CPU随机唤醒，公平则按请求锁的顺序进入加锁代码（FIFO）
      + synchronized非公平
      + lock默认非公平，但可以设置为公平锁：构造方法传入true
  + 竞争激烈以及情况对应的情况下，可以考虑使用Lock，否则使用synchronized更加合理，因为官方对synchronized的优化比较推荐
  
  + 原理？？
