# View是怎么画出来的（一）——基础

* Android设备的显示屏被抽象为一个帧缓冲区（frame buffer,fb）。SurfaceFlinger通过向这个帧缓冲区写入内容来绘制界面。帧缓冲区的所有操作，在硬件抽象层被封装成了Gralloc模块。
* Linux内核启动的时候会创建一个类别为”graphics”，名字为”fb0”的设备，如果有多个显示屏，还会有fbx，这是一个设备文件，描述了显示屏。通过打开fb，获得一个内存，映射到本进程空间之后，对其进行写入，则可以将内容显示出来。
* init系统启动过程中，会启动ueventd进程，这个进程执行的程序和init是同一个，但由条件判断走了不一样的分支。ueventd进程用来管理系统的设备文件，其作用类似Linux中的udev，用于管理设备，如命名、如内核检测到设备插拔，都由ueventd来生成设备文件。
* 用户控件的应用进程，先加载gralloc模块，用gralloc申请图形缓冲区，并映射入本进程空间，写入要绘制的内容。然后再把图形缓冲区，通过fb，写入帧缓冲区。
* 分配图形缓冲区，有两种方式，一种是直接在帧缓冲区上分配图形缓冲区，这样的话写入的内容就相当于直接写入帧缓冲区。第二种是在进程空间分配图形缓冲区，这使用的是匿名贡献内存。一般情况下，只有SurfaceFlinger会在帧缓冲区直接分配，而用户程序和SurfaceFlinger都会用匿名共享内存。
* 在内存中分配图形缓冲区的方法，也是需要通过SurfaceFlinger，由其创建一块匿名共享内存，然后和请求分配的进程共享。
* 渲染过程：

  * 如果是直接映射在帧缓冲区的，直接写入，然后通知设备，以该图形缓冲区为输出，因为一个帧缓冲区可能有多个图形缓冲区。
  * 如果是以匿名内存的，写入之后，需要memcpy入帧缓冲区。（这有疑问）
* 总结：

  * 加载Gralloc
  * 打开Gralloc模块中的gralloc设备和fb设备。
  * 使用gralloc分配一个匹配屏幕大小的图形缓冲区。
  * 分配好的图形缓冲区映射到本进程空间。
  * 将绘制的内容写入图形缓冲区，然后渲染到帧缓冲区（fb设备）去。
